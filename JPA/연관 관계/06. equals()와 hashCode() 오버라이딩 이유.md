# 복합키에서 equals()와 hashCode()를 오버라이딩 하는 이유

## 💡 앞서 자바의 Object 비교를 살펴보자
- 자바의 모든 클래스는 기본적으로 Object 클래스를 상속받는다.
- 이 클래스가 제공하는 equals() 메소드는 인스턴스 참조값(메모리 주소값)을 비교한다.
    - 즉, 같은 객체(인스턴스)일 경우에만 동일하다고 판단한다.

<br>
<br>

## 💡 JPA에서 equals()와 hashCode()를 오버라이딩 하는 이유
- JPA는 영속성 컨텍스트에 엔티티를 보관할 때 엔티티의 식별자를 키로 사용한다.
- 이때 식별자 필드가 하나일 경우에는 보통 자바의 기본 타입을 사용하기 때문에 문제가 되지 않는다.
- equals() 메소드는 두 식별자 객체가 동등한지를 비교하고, hashCode() 메소드는 동일한 객체를 식별하기 위한 해시코드를 반환한다.

### 왜 그러면 equals()와 hashCode()를 같이 쓰는 건가?
- 일반적으로 한 엔티티 매니저의 영속성 컨텍스트에서 1차 캐시를 이용해 같은 ID의 엔티티를 항상 같은 객체로 가져올 수 있다.
- 그러나, 1차 캐시를 초기화 한 후 DB에서 동일한 엔티티를 읽어오는 경우 초기화 전에 얻었던 객체와 초기화 후에 얻은 객체가 서로 다른 객체로 생성되게 된다. (메모리값이 달라지기 때문)
- 이는 equals() 메소드에 위반되기 때문에 인스턴스 주소값으로만 객체를 판단해선 안 된다.
- 따라서 hashCode() 메소드를 통해 해당 필드들을 기반으로 해시코드를 생성한 다음 비교까지 해줘야 완전히 동일한 객체를 가져올 수 있게 된다.

즉, 엔티티는 그 본질이 자바 객체라기 보단, 데이터베이스 테이블의 레코드에 가깝기 때문에

엔티티 객체의 필드가 동일하다면 같은 레코드, 즉 같은 객체라고 판단을 해야 한다.

이 경우 Object의 equals() 메소드만으로는 해결할 수 없기 때문에 hashCode() 메소드도 같이 사용하는 것이다.