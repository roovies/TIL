# JWT를 배우기에 앞서..

## 1. 인증(Authentication)과 인가(Authorization)의 차이
- **인증(Authentication) :** 쉽게 말해서 로그인, 즉 해당 사이트에 가입된 회원임을 확인하는 것
- **인가(Authorization) :** 한 번 `인증`을 받은 사용자가 여러 서비스를 사용하려고 할 때, 로그인이 되었음을 확인하고 허가해주는 것

    (즉, 로그인이 유지되는 상태에서 일어나는 일)

## 2. 인가 방식 중 하나인 “세션”
- 어떤 사용자가 서버에 로그인이 되어 있는 지속적인 상태를 “세션”이라고 한다.
    ```
    [세션의 동작 방식]
    - 사용자가 로그인에 성공하면 서버는 일종의 '세션 표딱지'를 출력한다.
    - '세션 표딱지'의 반쪽은 사용자 브라우저, 다른 반쪽은 메모리에 올린다.
    - 사용자 브라우저가 요청 시 클라이언트는 서버에게 Session ID라는 쿠키를 보내게 되고,
      서버는 이에 맞는 반쪽을 찾는 형태이다.
    
    [세션 표딱지의 위치]
    - 사용자 브라우저가 가진 '세션 표딱지'를 Session ID라는 이름의 쿠키로 저장해둔다.
    - '세션 표딱지'의 나머지 절반은 서버가 메모리에 갖고 있는다.
    
    [세션의 단점]
    - 동시 접속 사용자가 많아지게 되면, 메모리가 고갈될 수 있다.
    - 휘발성 메모리에 저장하기 때문에 서버 재부팅 시 저장된 세션 정보들이 삭제된다.
    - 서버마다 세션 스토리지가 있기 때문에, 다수의 서버를 운영하는 경우 로드밸런싱 시 문제가 된다.
    
    [다수의 서버를 운영할 때 세션을 사용하는 법]
    - Redis 같은 인메모리 DB를 사용한다.
    ```

<br>

# JWT (Java Web Token)
## 1. JWT란?
- **JWT는 Java Web Token의 약자이다.**
- **JSON을 이용하여 사용자 속성을 저장하는 Claim 기반의 웹 토큰이다.**
    - 즉, JWT는 정보가 토큰 자체에 포함된 (Self-Contained) 클레임(Claim) 기반 토큰이다.

      [Claim 기반 토큰이란?](https://www.notion.so/Claim-31a6f773a79b44eba553370ddf5f407d?pvs=21)

- **JWT는 인증(Authentication)과 인가(Authorization)에 사용되는 것이 가장 일반적이다.**
    - 인증 절차를 거쳐 서버에서 JWT를 발급해주면, 클라이언트는 이를 잘 보관하고 있다가 API 등을 사용할 때 서버에 JWT를 함께 제출함으로써 서버로부터 행위에 대해 인가를 받을 수 있다.
- **JWT는 해시 혹은 비대칭키 방식을 사용하여 서명(Signature) 하기 때문에 무결성을 검증할 수 있다.**
- **또한, 토큰 자신이 직접 정보를 포함하고 있는 특징 덕분에 통신 양자 간 정보를 안전하게 전송할 때에도 사용된다.**
- **이러한 JWT는 URL에 대해 안전한 (URL-Safe) 문자열로 구성되어 있으므로 어떤 경로로든 전송할 수 있다.**

## 2. 서버 기반 인증 vs 토큰 기반 인증
- **HTTP는 무상태(Stateless) 프로토콜이다.**
    - 무상태 프로토콜이란, 각각의 요청을 이전 요청과 관계 없는 독립적인 새로운 요청으로 취급한다.
- **따라서 HTTP 그 자체만으로는 사용자가 아무리 인증에 성공한다 하더라도, 인증에 성공한 상태가 어디에도 저장되지 않는다.**
    - 로그인 후, 다음 페이지로 이동한 후에 다시 로그인을 해야 한다는 의미이다.
- **이런 한계를 극복하기 위해 여러 인증 방법이 등장하게 되었는데, 그 중에 서버 기반 인증과 토큰 기반 인증 2가지에 대해 알아볼 것이다.**
    - 정보보안에서 공부했을 때, Keep-Alive 속성을 통해 일정 시간 동안은 연결을 유지하여 Stateful하게 설정할 수 있었다.

### 2-1. 서버 기반 인증
- **서버 기반 인증에서는 사용자가 성공적으로 로그인하면, 서버에서 사용자에 대한 세션을 생성하고, 사용자의 브라우저(클라이언트)에는 세션ID를 저장하는 쿠키가 생성된다.**
    - 서버는 해당 세션ID를 통해 사용자를 식별하고 사용자에 대한 정보를 저장, 관리한다.

    ```
    "서버에서 사용자에 대한 모든 정보를 갖고 있다."
    위 특징을 실제 운영하는 서비스에서 생각해보자.
    
    만약 서버에 저장할 수 있는 양을 넘을 정도로 사용자가 증가하게 된다면?
    당연히 서버를 업그레이드 해야 한다.
    이렇게 단일 컴퓨터의 장비를 고성능으로 교체하는 방식을 "수직 확장(Scale Up)"이라 한다.
    
    그러나, 성능 증가에 따른 비용의 증가폭이 크기 때문에 경제적으로 부담이 된다.
    
    또한 이렇게 할 경우 하나의 서버만 운영하게 되므로, 만약 해당 서버에 장애가 발생하게 되면
    모든 서비스에 접근할 수 없게 될 것이다.
    이러한 서비스는 "단일 장애 지점(SPOF: Single Point Of Failure)"을 갖게 된다.
    
    따라서 하나의 서버가 아닌, 여러 대의 서버를 한 번에 운용하기 위해서, 서버를 여러 대 두어
    확장하는 방식을 "수평 확장(Scale Out)"이라 한다.
    
    "수평 확장(Scale Out)"을 통해 경제적 부담도 줄이며, 하나의 서버에 장애가 발생하더라도 다른
    서버로 동작시키면 되므로 안정성도 높아진다.
    
    그러나, 여러 대의 서버를 운용하면 데이터의 불일치 문제가 생길 수도 있다.
    즉, 모든 서버가 메모리에 동일한 세션 정보를 가지고 있지 않기 때문에,
    유저가 서비스를 이용하는 중에 로그인이 풀릴 수도 있는 것이다.
    
    이를 해결하기 위해 운용 중인 모든 서버에 로그인한 유저 세션 ID를 모두 공유해야 하는데,
    쉽지 않다.
    ```


### 2-2. 토큰 기반 인증
- **세션과 다르게, 토큰 기반 인증은 유저의 정보를 서버에 저장하지 않는다.**
    - 유저가 로그인에 성공하면, 서버는 클라이언트에게 토큰(일반적으로 JWT)을 발급해준다.
- **클라이언트는 토큰을 받아 저장하고, 서버에 요청할 때마다 HTTP Header에 토큰을 함께 실어서 전송한다.**
- **서버는 클라이언트가 전송한 토큰을 검증(Vertification)하고, 검증에 성공하면 해당 클라이언트를 인가한다.**
- **이처럼 토큰 기반 인증 방식에서 서버는 단순히 `발급`과 `검증` 2가지 역할만 할 뿐, 유저에 대한 정보를 직접 갖고 있지 않다.**
    - 즉, 유저 상태의 저장 책임이 서버에서 클라이언트로 이동된 것이다.
- **하지만, JWT와 같이 토큰 자체에 정보가 저장되는 형태의 토큰은 세션과 달리 클라이언트쪽에 유저 정보가 저장되므로, 유출되기가 쉽다.**
- **따라서 토큰에 민감 정보를 담아서는 절대 안 된다.**
- **또한, 토큰의 크기는 세션ID에 비해 크기 때문에, 토큰 기반 인증을 사용하면, 통신하면서 발생하는 오버헤드를 감안해야 하는 단점이 존재한다.**

  > 이전에는 의미 없는 랜덤 문자열 등을 생성하는 토큰 기반 인증을 구현했는데,
  토큰에 만료 시간 같은 정보를 담을 수 없어 따로 만료시킬 수단이 존재하지 않았다.
  > 
  > 그러나 JWT의 경우 데이터를 직접 갖고 있는 클레임(Claim) 기반 토큰이므로, 토큰의 만료를 구현할 수 있게 되었다.


## 3. JWT의 구조
![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8607151f-3a54-4338-b81d-5e8d5a35c81c/Untitled.png)
- **JWT는 점(.)을 기준으로 [Header.Payload.Signature] 로 구성되어 있다.**
    - 이때 각각의 파트는 JSON 데이터가 Base64url로 인코딩 되어 있다.
- **이렇게 Base64url로 인코딩 하는 이유는 다음과 같다.**
    1. JSON은 “\n”과 같은 개행문자가 있으므로, REST API 호출 시 HTTP Header에 넣기가 불편하기 때문에 한줄로 나타내기 위해 각 구성 요소를 Base64url로 인코딩하게 된다.
    2. ase64로 인코딩 할 경우 +, /, = 등이 포함되기 때문에 URI에서 파라미터로 사용할 수 있도록 URL-Safe 한 Base64url 인코딩을 사용한다.

### 3-1. Header
> **토큰의 유형과 암호화 알고리즘 2가지 정보를 JSON 형태로 담고 있다.**
- `type` : 토큰 유형 (보통 JWT가 들어감)
- `alg` : 암호화 알고리즘 (HMAC, SHA256, RSA …)

### 3-2. Payload
> **Payload는 사용자의 정보 혹은 데이터 속성 등을 나타내는 클레임(Claim) 이라는 정보 단위로 구성된다.**
> 
> 이때 클레임(Claim)도 3가지로 구분할 수 있다.
> - 등록된 클레임 (Registered Claim)
> - 공개 클레임 (Public Claim)
> - 비공개 클레임 (Private Claim)**

**🔸 등록된 클레임 (Registered Claim)**
- JWT에서 토큰에 대한 정보들을 담기 위하여 이름이 이미 정해진 클레임이다.
- 등록된 클레임 사용은 선택적이다.
    - `iss` : 토큰 발급자 (Issuer)
    - `sub` : 토큰 제목 (Subject)
    - `aud` : 토큰 대상자 (Audience)
    - `exp` : 토큰 만료 시간 (Expiration Time)
        - Numeric Date 형식으로 나타냄 ex) 1480849147370
    - `nbf` : 토큰 활성화 시간 (Not Before)
        - Numeric Date 형식으로 나타냄
        - 쉽게 말해서 nbf 시간 이전에는 토큰이 유효하지 않음
    - `iat` : 토큰이 발급된 시간 (Issued At)
        - Numeric Date 형식으로 나타냄
    - `jti` : JWT 식별자 (JWT ID)

**🔸 공개 클레임 (Public Claim)**
- 공개 클레임은 JWT를 사용하는 사용자들에 의해 정의되는 클레임이다.
- 충돌 방지를 위해 URI 형태로 이름을 짓거나, **[여기](https://www.iana.org/assignments/jwt/jwt.xhtml)** 에서 직접 클레임을 등록해야 한다.
- 서버-클라이언트 사이의 단순 통신을 넘어, 제 3자도 JWT 토큰을 사용할 때 충돌이 일어나지 않도록 합의된 클레임이라 생각하면 된다.
    - 사실 JWT를 단순히 서버와 클라이언트 사이에서 사용자를 인증하는 용도로 사용한다면, 크게 신경쓰지 않아도 좋다.
    ```json
    {
      "email": "sample@domain.com",
      "profile": "http://domain.com/image.png",
      "http://domain.com/xxx/yyy/is_admin": true
    }
    ```
- 위 처럼 등록된 공개 클레임인 email, profile 등을 사용할 수도 있고, URI 형태로도 사용할 수 있다.


**🔸 비공개 클레임 (Private Claim)**
- 비공개 클레임은 서버와 클라이언트 사이에서만 협의된 클레임이다.
- 공개 클레임과 충돌이 발생하지 않게 사용해야 한다.
    ```json
    {
        "user_id" : "roovies",
        "user_nickname" : "루비즈"
    }
    ```

### 3-3. Signature
> **Signature는 Header의 alg에 정의된 암호화 알고리즘을 사용하여 Base64url로 인코딩된 Header와 Payload 그리고 비밀키를 이용하여 암호화 한다.**
> 
> **서명을 통해 서버는 헤더 혹은 페이로드가 누군가에 의해 변조되었는지 무결성을 검증할 수 있다.**

<br>

## 4. JWT를 이용한 인증 과정
> **위 토큰 기반 인증에서 간단하게 서술했지만, JWT로 자세하게 다시 설명해보겠다.**
1. JWT를 이용한 인증 방식은 유저 정보를 토큰에 저장해두고 클라이언트에게 응답하기 때문에 따로 서버에 저장해두지 않는다.
2. 따라서 메모리 부담은 적지만, 토큰을 탈취당하면 토큰을 악용하는 요청에 대해 대응할 수가 없다.
3. 그래서 토큰의 주기를 짧게 설정하고, 다른 토큰을 하나 더 생성하여 긴 주기를 가지게 하여 redis에 토큰 정보를 저장하는 방법을 많이 채택하고 있다.
4. 이때 짧게 주기를 가져간 토큰을 **Access Token**이라 하고, 만료된 **Access Token**을 재발행(reissue)하기도 한다.
5. 그리고 긴 주기(보통 2주)를 가지는 토큰을 **Refresh Token**이라 한다.
```json
Access Token + Refresh Token을 같이 관리하는 JWT 방식
1. 로그인 시 서버는 클라이언트에게 Access Token과 Refresh Token을 발급해준다.
2. 클라이언트는 Access Token을 통해 자유롭게 서비스를 이용한다.
3. 클라이언트가 특정 API 인가 시, Access Token이 만료되었다면 Refresh Token을 서버에 전송한다.
4. 서버는 Redis 혹은 DB에 저장된 Refresh Token과 대조해보고, 올바른 토큰이면 해당 클라이언트에게
   새 Access Token을 발급해준다.
```

<br>

## 5. 실무에서의 JWT
- 실제 실무에서는 JWT만 사용하는 경우는 비교적 적다.
- 간단한 프로젝트, 예민하지 않은 데이터를 다루며 경제성을 고려할 때 JWT 사용을 권장한다.

  그러나 조금이라도 보안이 요구된다면 세션을 권장한다.

- API 호출이 많은 사이트일수록 JWT로 인한 Overhead가 있기 때문에 JWT를 사용하지 않는다.
- JWT도 대칭키가 아닌 비대칭키로 사용할 수도 있다 (키워드 : JWKS)

## # References
- https://hudi.blog/self-made-jwt/
- https://blossom6729.tistory.com/22