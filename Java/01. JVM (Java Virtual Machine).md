# JVM (Java Virtual Machine)
> Java Virutal Machine (자바 가상 머신)은 자바 프로그램을(.java) 실행하기 위한 가상머신이다.
<br>

## 💡 JVM의 특징
![jvm](https://github.com/roovies/TIL/assets/119032680/5e2fa973-aa9c-4420-aefc-26cdad332fd7)
1. C나 C++의 경우 컴파일 언어로써, 컴파일 단계에서 소스코드를 OS나 CPU에 맞는 기계어로 변환한다. <br>
    따라서 OS에 종속적이다.
2. 반면 자바에서는 JVM이 자바와 프로그램과 OS 사이에 위치하여 중개자 역할을 해준다.
3. 그 덕분에 JVM만 설치되어 있으면 자바 프로그램은 어떠한 OS에서든 실행 가능하다.
### 즉, 모든 플랫폼(OS, CPU)에서 제약없이 자바 프로그램을 실행시키기 위해 JVM이 필요하다.

<br>

## 💡 JVM의 동작원리
![자바코드_실행과정](https://github.com/roovies/TIL/assets/119032680/8a18c153-1f1e-4291-825b-6241260575b8)
#### ✅ JVM은 ```클래스 로더(Class Loader)```, ```런타임 데이터 영역(Runtime Data Areas)```, ```실행 엔진(Execution Engine)```으로 이루어져있다.
#### ✅ 이때 자바 컴파일러(javac)에 의해 컴파일된 바이트 코드를 JVM의 ```클래스 로더```가 전달 받는다.
1. 자바 프로그램(.java)이 실행되면 JVM은 OS로부터 자바 프로그램이 필요로하는 메모리를 할당 받는다.
2. **자바 컴파일러**(javac)가 자바 소스코드(.java)를 읽고, 자바 바이트 코드(.class)로 컴파일 한다.
3. **클래스 로더**에 의해 필요한 class 파일들을 JVM 메모리 영역(Runtime Data Areas)에 로드하고, 링크 작업을 수행한다.
4. **Runtime Data Area**에 올라간(로딩된) 바이트 코드는 **실행 엔진**이 코드들을 명령어 단위로 하나씩 가져와서 해석하고 실행한다.
5. 해석된 바이트 코드는 **메모리 영역에 배치되어 실질적인 수행**이 이루어진다.
    <br> 이러한 실행 과정 속에서 JVM은 필요에 따라 ```가비지 컬렉터```로 사용되지 않는 객체를 제거하여메모리를 관리하거나, ```스레드 동기화```를 통해 다중 스레드 환경에서 안정적인 실행을 보장해준다.

<br>

## 💡 JVM의 구조
![jvm구조](https://github.com/roovies/TIL/assets/119032680/9823f55b-bfe2-4410-b7e4-7191571605d5)
### 1) Class Loader
* 런타임 시에 로드된 .class 바이트코드를 ```Runtime Data Area``` JVM 메모리 영역에 배치시킨다.
* 로딩 순서는 Loading → Linking → Initialization 이다.
  1. **Loading** : JVM 메모리 영역에 올리는 작업
  2. **Linking** : 클래스가 필요로하는 메모리를 할당하는 등, 클래스 파일을 사용하기 위한 검증 과정
  3. **Initialization** : 클래스 변수들을 초기화 (static 키워드 붙은 것들을 지정한 값으로 초기화)

### 2) Runtime Data Areas
* JVM이 프로그램을 수행하기 위해 OS로부터 할당받은 메모리 공간 (즉, JVM 메모리 영역)
![jvm-runtime-data-area-structure](https://github.com/roovies/TIL/assets/119032680/d6d949f2-2d84-4359-9201-681064741cc7)
* ```Method Area```, ```Heap``` 영역은 **_모든 스레드가 공유하고_**, 나머지 공간들은 스레드마다 하나씩 생성된다.
    #### 2-1. Method Area
  * class 영역, static 영역이라고도 한다.
  * JVM이 읽은 각각의 클래스와 인터페이스, 메소드 정보, Type 정보들이 저장되는 공간이다.
  * JVM이 시작될 때 생성되고, JVM이 종료될 때까지 유지된다. (Stack과 차이점)
  * 모든 스레드가 참조할 수 있는 영역이다. (Stack과 차이점)
  #### 2-2. Heap 영역
  * 동적으로 생성된 데이터가 저장되는 영역이다.
  * 대표적으로 아래 항목들이 저장된다.
    + new 연산자로 생성되는 클래스
    + 인스턴스 변수 (static 키워드가 없는 class 필드)
    + Reference Type 변수
  * Heap에는 실제 데이터가 존재하고, 주소값은 ```Stack```이 갖고 있다.
  #### 2-3. Stack 영역
  * 스레드마다 별도의 Stack이 생성되며, 스레드 실행 시 필요한 데이터를 저장한다.
  * 지역변수, 매개변수, 메소드 정보, 임시 데이터 등을 저장하는 공간이다.
  * 스레드별로 독립적인 영역으로서, 스레드 간의 데이터 공유가 이루어지지 않는다.
  * Stack Frame이라는 작은 블록들로 구성되어 있는데, 메소드 호출 시 Stack Frame이 추가되고, 메소드 종료 시 해당 Stack Frame이 제거된다.
    > **Method Area와 Stack의 차이점**
    > > Method Area는 ```클래스```와 ```인터페이스```에 대한 정보를 저장하고 모든 스레드에서 참조할수 있는 영역이다.
    > <br> 반면에 Stack은 스레드마다 별도로 생성되어 실행 흐름과 관련된 데이터를 저장하는 영역이다.
    #### 2-4. PC Register
  * 스레드가 시작될 때 생성된다.
  * JVM에서 현재 수행 중인 명령어 주소를 저장하는 공간이다.
  #### 2-5. Native Method Stack
  * 바이트 코드가 아닌, 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다.
  * 즉, Java가 아닌 네이티브 언어(C, C++ 등)를 위한 영역이다.

### 3) Excution Engine
* Runtime Data Area에 로드된 클래스 파일의 바이트 코드를 실행하는 엔진이다.
* 바이트 코드를 실행시키기 위해서 ```바이트 코드를 기계어로 바꾸는 작업```이 필요한데, 2가지 방법이 있다.
  1. ```인터프리터``` : 명령어를 한줄 한줄 해석해서 실행한다.
  2. ```JIT (Just-In-Time) 컴파일러``` : 인터 프리터의 단점을 보완하여, 반복되는 코드는 바이트 코드 → Native Code로 변경하여 캐싱해둔 후, Native Code로 실행시킨다.

### 4) Garbage Collector
* Heap 메모리 영역에서 안 쓰는 메모리를 자동으로 회수해준다. 
* C++는 할당된 메모리를 따로 delete 해줘서 메모리 할당 해제를 해줘야 하는데, JVM이 이걸 대신 해주는 것이다.
* 그래서 Java에는 메모리 할당 기능(new)만 존재한다.
### 5) JNI (Java Native Interface)
* 자바 애플리케이션에서 네이티브 언어(C, C++ 등)로 작성된 메소드를 사용할 수 있는 방법을 제공해준다.
### 6) Native Method Library
* 네이티브 언어(C, C++ 등)로 작성된 라이브러리이다.